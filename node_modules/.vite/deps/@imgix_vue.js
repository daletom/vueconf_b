import {
  defineComponent,
  h
} from "./chunk-QRO6HSH3.js";

// node_modules/@imgix/vue/dist/imgix-vue.esm.js
var version = "3.7.2";
var VERSION$2 = version;
var _hasatob = typeof atob === "function";
var _hasbtoa = typeof btoa === "function";
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = function(a) {
  var tab = {};
  a.forEach(function(c2, i) {
    return tab[c2] = i;
  });
  return tab;
}(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : function(it, fn) {
  if (fn === void 0)
    fn = function(x) {
      return x;
    };
  return new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
};
var _mkUriSafe = function(src) {
  return src.replace(/=/g, "").replace(/[+\/]/g, function(m0) {
    return m0 == "+" ? "-" : "_";
  });
};
var _tidyB64 = function(s2) {
  return s2.replace(/[^A-Za-z0-9\+\/]/g, "");
};
var btoaPolyfill = function(bin) {
  var u32, c0, c1, c2, asc = "";
  var pad = bin.length % 3;
  for (var i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255) {
      throw new TypeError("invalid character found");
    }
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
var _btoa = _hasbtoa ? function(bin) {
  return btoa(bin);
} : _hasBuffer ? function(bin) {
  return Buffer.from(bin, "binary").toString("base64");
} : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? function(u8a) {
  return Buffer.from(u8a).toString("base64");
} : function(u8a) {
  var maxargs = 4096;
  var strs = [];
  for (var i = 0, l = u8a.length; i < l; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = function(u8a, urlsafe) {
  if (urlsafe === void 0)
    urlsafe = false;
  return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
};
var cb_utob = function(c2) {
  if (c2.length < 2) {
    var cc = c2.charCodeAt(0);
    return cc < 128 ? c2 : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c2.charCodeAt(0) - 55296) * 1024 + (c2.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = function(u2) {
  return u2.replace(re_utob, cb_utob);
};
var _encode = _hasBuffer ? function(s2) {
  return Buffer.from(s2, "utf8").toString("base64");
} : _TE ? function(s2) {
  return _fromUint8Array(_TE.encode(s2));
} : function(s2) {
  return _btoa(utob(s2));
};
var encode$1 = function(src, urlsafe) {
  if (urlsafe === void 0)
    urlsafe = false;
  return urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
};
var encodeURI$1 = function(src) {
  return encode$1(src, true);
};
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = function(cccc) {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
var btou = function(b) {
  return b.replace(re_btou, cb_btou);
};
var atobPolyfill = function(asc) {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc)) {
    throw new TypeError("malformed base64.");
  }
  asc += "==".slice(2 - (asc.length & 3));
  var u24, bin = "", r1, r2;
  for (var i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
var _atob = _hasatob ? function(asc) {
  return atob(_tidyB64(asc));
} : _hasBuffer ? function(asc) {
  return Buffer.from(asc, "base64").toString("binary");
} : atobPolyfill;
var _toUint8Array = _hasBuffer ? function(a) {
  return _U8Afrom(Buffer.from(a, "base64"));
} : function(a) {
  return _U8Afrom(_atob(a), function(c2) {
    return c2.charCodeAt(0);
  });
};
var toUint8Array = function(a) {
  return _toUint8Array(_unURI(a));
};
var _decode = _hasBuffer ? function(a) {
  return Buffer.from(a, "base64").toString("utf8");
} : _TD ? function(a) {
  return _TD.decode(_toUint8Array(a));
} : function(a) {
  return btou(_atob(a));
};
var _unURI = function(a) {
  return _tidyB64(a.replace(/[-_]/g, function(m0) {
    return m0 == "-" ? "+" : "/";
  }));
};
var decode$1 = function(src) {
  return _decode(_unURI(src));
};
var isValid = function(src) {
  if (typeof src !== "string") {
    return false;
  }
  var s2 = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s2) || !/[^\s0-9a-zA-Z\-_]/.test(s2);
};
var _noEnum = function(v) {
  return {
    value: v,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
var extendString = function() {
  var _add = function(name, body) {
    return Object.defineProperty(String.prototype, name, _noEnum(body));
  };
  _add("fromBase64", function() {
    return decode$1(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode$1(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode$1(this, true);
  });
  _add("toBase64URL", function() {
    return encode$1(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array(this);
  });
};
var extendUint8Array = function() {
  var _add = function(name, body) {
    return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
  };
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
var extendBuiltins = function() {
  extendString();
  extendUint8Array();
};
var gBase64 = {
  version,
  VERSION: VERSION$2,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode$1,
  toBase64: encode$1,
  encode: encode$1,
  encodeURI: encodeURI$1,
  encodeURL: encodeURI$1,
  utob,
  btou,
  decode: decode$1,
  isValid,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};
var md5$1 = { exports: {} };
var crypt = { exports: {} };
(function() {
  var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt$1 = {
    rotl: function(n2, b) {
      return n2 << b | n2 >>> 32 - b;
    },
    rotr: function(n2, b) {
      return n2 << 32 - b | n2 >>> b;
    },
    endian: function(n2) {
      if (n2.constructor == Number) {
        return crypt$1.rotl(n2, 8) & 16711935 | crypt$1.rotl(n2, 24) & 4278255360;
      }
      for (var i = 0; i < n2.length; i++) {
        n2[i] = crypt$1.endian(n2[i]);
      }
      return n2;
    },
    randomBytes: function(n2) {
      for (var bytes = []; n2 > 0; n2--) {
        bytes.push(Math.floor(Math.random() * 256));
      }
      return bytes;
    },
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8) {
        words[b >>> 5] |= bytes[i] << 24 - b % 32;
      }
      return words;
    },
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8) {
        bytes.push(words[b >>> 5] >>> 24 - b % 32 & 255);
      }
      return bytes;
    },
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 15).toString(16));
      }
      return hex.join("");
    },
    hexToBytes: function(hex) {
      for (var bytes = [], c2 = 0; c2 < hex.length; c2 += 2) {
        bytes.push(parseInt(hex.substr(c2, 2), 16));
      }
      return bytes;
    },
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
        for (var j = 0; j < 4; j++) {
          if (i * 8 + j * 6 <= bytes.length * 8) {
            base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63));
          } else {
            base64.push("=");
          }
        }
      }
      return base64.join("");
    },
    base64ToBytes: function(base64) {
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
      for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
        if (imod4 == 0) {
          continue;
        }
        bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
      }
      return bytes;
    }
  };
  crypt.exports = crypt$1;
})();
var charenc = {
  utf8: {
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },
  bin: {
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++) {
        bytes.push(str.charCodeAt(i) & 255);
      }
      return bytes;
    },
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++) {
        str.push(String.fromCharCode(bytes[i]));
      }
      return str.join("");
    }
  }
};
var charenc_1 = charenc;
var isBuffer_1 = function(obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};
function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
}
(function() {
  var crypt$1 = crypt.exports, utf8 = charenc_1.utf8, isBuffer2 = isBuffer_1, bin = charenc_1.bin, md52 = function(message, options) {
    if (message.constructor == String) {
      if (options && options.encoding === "binary") {
        message = bin.stringToBytes(message);
      } else {
        message = utf8.stringToBytes(message);
      }
    } else if (isBuffer2(message)) {
      message = Array.prototype.slice.call(message, 0);
    } else if (!Array.isArray(message) && message.constructor !== Uint8Array) {
      message = message.toString();
    }
    var m = crypt$1.bytesToWords(message), l = message.length * 8, a = 1732584193, b = -271733879, c2 = -1732584194, d = 271733878;
    for (var i = 0; i < m.length; i++) {
      m[i] = (m[i] << 8 | m[i] >>> 24) & 16711935 | (m[i] << 24 | m[i] >>> 8) & 4278255360;
    }
    m[l >>> 5] |= 128 << l % 32;
    m[(l + 64 >>> 9 << 4) + 14] = l;
    var FF = md52._ff, GG = md52._gg, HH = md52._hh, II = md52._ii;
    for (var i = 0; i < m.length; i += 16) {
      var aa = a, bb = b, cc = c2, dd = d;
      a = FF(a, b, c2, d, m[i + 0], 7, -680876936);
      d = FF(d, a, b, c2, m[i + 1], 12, -389564586);
      c2 = FF(c2, d, a, b, m[i + 2], 17, 606105819);
      b = FF(b, c2, d, a, m[i + 3], 22, -1044525330);
      a = FF(a, b, c2, d, m[i + 4], 7, -176418897);
      d = FF(d, a, b, c2, m[i + 5], 12, 1200080426);
      c2 = FF(c2, d, a, b, m[i + 6], 17, -1473231341);
      b = FF(b, c2, d, a, m[i + 7], 22, -45705983);
      a = FF(a, b, c2, d, m[i + 8], 7, 1770035416);
      d = FF(d, a, b, c2, m[i + 9], 12, -1958414417);
      c2 = FF(c2, d, a, b, m[i + 10], 17, -42063);
      b = FF(b, c2, d, a, m[i + 11], 22, -1990404162);
      a = FF(a, b, c2, d, m[i + 12], 7, 1804603682);
      d = FF(d, a, b, c2, m[i + 13], 12, -40341101);
      c2 = FF(c2, d, a, b, m[i + 14], 17, -1502002290);
      b = FF(b, c2, d, a, m[i + 15], 22, 1236535329);
      a = GG(a, b, c2, d, m[i + 1], 5, -165796510);
      d = GG(d, a, b, c2, m[i + 6], 9, -1069501632);
      c2 = GG(c2, d, a, b, m[i + 11], 14, 643717713);
      b = GG(b, c2, d, a, m[i + 0], 20, -373897302);
      a = GG(a, b, c2, d, m[i + 5], 5, -701558691);
      d = GG(d, a, b, c2, m[i + 10], 9, 38016083);
      c2 = GG(c2, d, a, b, m[i + 15], 14, -660478335);
      b = GG(b, c2, d, a, m[i + 4], 20, -405537848);
      a = GG(a, b, c2, d, m[i + 9], 5, 568446438);
      d = GG(d, a, b, c2, m[i + 14], 9, -1019803690);
      c2 = GG(c2, d, a, b, m[i + 3], 14, -187363961);
      b = GG(b, c2, d, a, m[i + 8], 20, 1163531501);
      a = GG(a, b, c2, d, m[i + 13], 5, -1444681467);
      d = GG(d, a, b, c2, m[i + 2], 9, -51403784);
      c2 = GG(c2, d, a, b, m[i + 7], 14, 1735328473);
      b = GG(b, c2, d, a, m[i + 12], 20, -1926607734);
      a = HH(a, b, c2, d, m[i + 5], 4, -378558);
      d = HH(d, a, b, c2, m[i + 8], 11, -2022574463);
      c2 = HH(c2, d, a, b, m[i + 11], 16, 1839030562);
      b = HH(b, c2, d, a, m[i + 14], 23, -35309556);
      a = HH(a, b, c2, d, m[i + 1], 4, -1530992060);
      d = HH(d, a, b, c2, m[i + 4], 11, 1272893353);
      c2 = HH(c2, d, a, b, m[i + 7], 16, -155497632);
      b = HH(b, c2, d, a, m[i + 10], 23, -1094730640);
      a = HH(a, b, c2, d, m[i + 13], 4, 681279174);
      d = HH(d, a, b, c2, m[i + 0], 11, -358537222);
      c2 = HH(c2, d, a, b, m[i + 3], 16, -722521979);
      b = HH(b, c2, d, a, m[i + 6], 23, 76029189);
      a = HH(a, b, c2, d, m[i + 9], 4, -640364487);
      d = HH(d, a, b, c2, m[i + 12], 11, -421815835);
      c2 = HH(c2, d, a, b, m[i + 15], 16, 530742520);
      b = HH(b, c2, d, a, m[i + 2], 23, -995338651);
      a = II(a, b, c2, d, m[i + 0], 6, -198630844);
      d = II(d, a, b, c2, m[i + 7], 10, 1126891415);
      c2 = II(c2, d, a, b, m[i + 14], 15, -1416354905);
      b = II(b, c2, d, a, m[i + 5], 21, -57434055);
      a = II(a, b, c2, d, m[i + 12], 6, 1700485571);
      d = II(d, a, b, c2, m[i + 3], 10, -1894986606);
      c2 = II(c2, d, a, b, m[i + 10], 15, -1051523);
      b = II(b, c2, d, a, m[i + 1], 21, -2054922799);
      a = II(a, b, c2, d, m[i + 8], 6, 1873313359);
      d = II(d, a, b, c2, m[i + 15], 10, -30611744);
      c2 = II(c2, d, a, b, m[i + 6], 15, -1560198380);
      b = II(b, c2, d, a, m[i + 13], 21, 1309151649);
      a = II(a, b, c2, d, m[i + 4], 6, -145523070);
      d = II(d, a, b, c2, m[i + 11], 10, -1120210379);
      c2 = II(c2, d, a, b, m[i + 2], 15, 718787259);
      b = II(b, c2, d, a, m[i + 9], 21, -343485551);
      a = a + aa >>> 0;
      b = b + bb >>> 0;
      c2 = c2 + cc >>> 0;
      d = d + dd >>> 0;
    }
    return crypt$1.endian([a, b, c2, d]);
  };
  md52._ff = function(a, b, c2, d, x, s2, t2) {
    var n2 = a + (b & c2 | ~b & d) + (x >>> 0) + t2;
    return (n2 << s2 | n2 >>> 32 - s2) + b;
  };
  md52._gg = function(a, b, c2, d, x, s2, t2) {
    var n2 = a + (b & d | c2 & ~d) + (x >>> 0) + t2;
    return (n2 << s2 | n2 >>> 32 - s2) + b;
  };
  md52._hh = function(a, b, c2, d, x, s2, t2) {
    var n2 = a + (b ^ c2 ^ d) + (x >>> 0) + t2;
    return (n2 << s2 | n2 >>> 32 - s2) + b;
  };
  md52._ii = function(a, b, c2, d, x, s2, t2) {
    var n2 = a + (c2 ^ (b | ~d)) + (x >>> 0) + t2;
    return (n2 << s2 | n2 >>> 32 - s2) + b;
  };
  md52._blocksize = 16;
  md52._digestsize = 16;
  md5$1.exports = function(message, options) {
    if (message === void 0 || message === null) {
      throw new Error("Illegal argument " + message);
    }
    var digestbytes = crypt$1.wordsToBytes(md52(message, options));
    return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt$1.bytesToHex(digestbytes);
  };
})();
var md5 = md5$1.exports;
var n = /[^\0-\x7E]/;
var t = /[\x2E\u3002\uFF0E\uFF61]/g;
var o = { overflow: "Overflow Error", "not-basic": "Illegal Input", "invalid-input": "Invalid Input" };
var e = Math.floor;
var r = String.fromCharCode;
function s(n2) {
  throw new RangeError(o[n2]);
}
var c = function(n2, t2) {
  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);
};
var u = function(n2, t2, o2) {
  var r2 = 0;
  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {
    n2 = e(n2 / 35);
  }
  return e(r2 + 36 * n2 / (n2 + 38));
};
function toASCII(o2) {
  return function(n2, o3) {
    var e2 = n2.split("@");
    var r2 = "";
    e2.length > 1 && (r2 = e2[0] + "@", n2 = e2[1]);
    var s2 = function(n3, t2) {
      var o4 = [];
      var e3 = n3.length;
      for (; e3--; ) {
        o4[e3] = t2(n3[e3]);
      }
      return o4;
    }((n2 = n2.replace(t, ".")).split("."), o3).join(".");
    return r2 + s2;
  }(o2, function(t2) {
    return n.test(t2) ? "xn--" + function(n2) {
      var t3 = [];
      var o3 = (n2 = function(n32) {
        var t42 = [];
        var o42 = 0;
        var e2 = n32.length;
        for (; o42 < e2; ) {
          var r2 = n32.charCodeAt(o42++);
          if (r2 >= 55296 && r2 <= 56319 && o42 < e2) {
            var e3 = n32.charCodeAt(o42++);
            (64512 & e3) == 56320 ? t42.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t42.push(r2), o42--);
          } else {
            t42.push(r2);
          }
        }
        return t42;
      }(n2)).length;
      var f = 128;
      var i = 0;
      var l = 72;
      for (var i$1 = 0, list = n2; i$1 < list.length; i$1 += 1) {
        var o4 = list[i$1];
        o4 < 128 && t3.push(r(o4));
      }
      var h2 = t3.length;
      var p = h2;
      for (h2 && t3.push("-"); p < o3; ) {
        var o4$1 = 2147483647;
        for (var i$2 = 0, list$1 = n2; i$2 < list$1.length; i$2 += 1) {
          var t4 = list$1[i$2];
          t4 >= f && t4 < o4$1 && (o4$1 = t4);
        }
        var a = p + 1;
        o4$1 - f > e((2147483647 - i) / a) && s("overflow"), i += (o4$1 - f) * a, f = o4$1;
        for (var i$3 = 0, list$2 = n2; i$3 < list$2.length; i$3 += 1) {
          var o5 = list$2[i$3];
          if (o5 < f && ++i > 2147483647 && s("overflow"), o5 == f) {
            var n3 = i;
            for (var o6 = 36; ; o6 += 36) {
              var s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;
              if (n3 < s2) {
                break;
              }
              var u2 = n3 - s2;
              var f2 = 36 - s2;
              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);
            }
            t3.push(r(c(n3, 0))), l = u(i, a, p == h2), i = 0, ++p;
          }
        }
        ++i, ++f;
      }
      return t3.join("");
    }(t2) : t2;
  });
}
var HASH_RE = /#/g;
var AMPERSAND_RE = /&/g;
var EQUAL_RE = /=/g;
var IM_RE = /\?/g;
var PLUS_RE = /\+/g;
var ENC_BRACKET_OPEN_RE = /%5B/gi;
var ENC_BRACKET_CLOSE_RE = /%5D/gi;
var ENC_CARET_RE = /%5E/gi;
var ENC_BACKTICK_RE = /%60/gi;
var ENC_CURLY_OPEN_RE = /%7B/gi;
var ENC_PIPE_RE = /%7C/gi;
var ENC_CURLY_CLOSE_RE = /%7D/gi;
var ENC_SPACE_RE = /%20/gi;
var ENC_SLASH_RE = /%2F/gi;
var ENC_ENC_SLASH_RE = /%252F/gi;
function encode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return encode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return encode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return encode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F").replace(ENC_ENC_SLASH_RE, "%2F").replace(AMPERSAND_RE, "%26").replace(PLUS_RE, "%2B");
}
function decode(text) {
  if (text === void 0)
    text = "";
  try {
    return decodeURIComponent("" + text);
  } catch (_err) {
    return "" + text;
  }
}
function decodePath(text) {
  return decode(text.replace(ENC_SLASH_RE, "%252F"));
}
function decodeQueryValue(text) {
  return decode(text.replace(PLUS_RE, " "));
}
function encodeHost(name) {
  if (name === void 0)
    name = "";
  return toASCII(name);
}
function parseQuery(paramsStr) {
  if (paramsStr === void 0)
    paramsStr = "";
  var obj = {};
  if (paramsStr[0] === "?") {
    paramsStr = paramsStr.substr(1);
  }
  for (var i = 0, list = paramsStr.split("&"); i < list.length; i += 1) {
    var param = list[i];
    var s2 = param.match(/([^=]+)=?(.*)/) || [];
    if (s2.length < 2) {
      continue;
    }
    var key = decode(s2[1]);
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    var value = decodeQueryValue(s2[2] || "");
    if (obj[key]) {
      if (Array.isArray(obj[key])) {
        obj[key].push(value);
      } else {
        obj[key] = [obj[key], value];
      }
    } else {
      obj[key] = value;
    }
  }
  return obj;
}
function encodeQueryItem(key, val) {
  if (!val) {
    return encodeQueryKey(key);
  }
  if (Array.isArray(val)) {
    return val.map(function(_val) {
      return encodeQueryKey(key) + "=" + encodeQueryValue(_val);
    }).join("&");
  }
  return encodeQueryKey(key) + "=" + encodeQueryValue(val);
}
function stringifyQuery(query) {
  return Object.keys(query).map(function(k) {
    return encodeQueryItem(k, query[k]);
  }).join("&");
}
var $URL = function $URL2(input) {
  if (input === void 0)
    input = "";
  this.query = {};
  if (typeof input !== "string") {
    throw new TypeError("URL input should be string received " + typeof input + " (" + input + ")");
  }
  var parsed = parseURL(input);
  this.protocol = decode(parsed.protocol);
  this.host = decode(parsed.host);
  this.auth = decode(parsed.auth);
  this.pathname = decodePath(parsed.pathname);
  this.query = parseQuery(parsed.search);
  this.hash = decode(parsed.hash);
};
var prototypeAccessors = { hostname: { configurable: true }, port: { configurable: true }, username: { configurable: true }, password: { configurable: true }, hasProtocol: { configurable: true }, isAbsolute: { configurable: true }, search: { configurable: true }, searchParams: { configurable: true }, origin: { configurable: true }, fullpath: { configurable: true }, encodedAuth: { configurable: true }, href: { configurable: true } };
prototypeAccessors.hostname.get = function() {
  return parseHost(this.host).hostname;
};
prototypeAccessors.port.get = function() {
  return parseHost(this.host).port || "";
};
prototypeAccessors.username.get = function() {
  return parseAuth(this.auth).username;
};
prototypeAccessors.password.get = function() {
  return parseAuth(this.auth).password || "";
};
prototypeAccessors.hasProtocol.get = function() {
  return this.protocol.length;
};
prototypeAccessors.isAbsolute.get = function() {
  return this.hasProtocol || this.pathname[0] === "/";
};
prototypeAccessors.search.get = function() {
  var q = stringifyQuery(this.query);
  return q.length ? "?" + q : "";
};
prototypeAccessors.searchParams.get = function() {
  var this$1$1 = this;
  var p = new URLSearchParams();
  var loop = function(name2) {
    var value = this$1$1.query[name2];
    if (Array.isArray(value)) {
      value.forEach(function(v) {
        return p.append(name2, v);
      });
    } else {
      p.append(name2, value || "");
    }
  };
  for (var name in this$1$1.query)
    loop(name);
  return p;
};
prototypeAccessors.origin.get = function() {
  return (this.protocol ? this.protocol + "//" : "") + encodeHost(this.host);
};
prototypeAccessors.fullpath.get = function() {
  return encodePath(this.pathname) + this.search + encodeHash(this.hash);
};
prototypeAccessors.encodedAuth.get = function() {
  if (!this.auth) {
    return "";
  }
  var ref = parseAuth(this.auth);
  var username = ref.username;
  var password = ref.password;
  return encodeURIComponent(username) + (password ? ":" + encodeURIComponent(password) : "");
};
prototypeAccessors.href.get = function() {
  var auth = this.encodedAuth;
  var originWithAuth = (this.protocol ? this.protocol + "//" : "") + (auth ? auth + "@" : "") + encodeHost(this.host);
  return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;
};
$URL.prototype.append = function append(url) {
  if (url.hasProtocol) {
    throw new Error("Cannot append a URL with protocol");
  }
  Object.assign(this.query, url.query);
  if (url.pathname) {
    this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);
  }
  if (url.hash) {
    this.hash = url.hash;
  }
};
$URL.prototype.toJSON = function toJSON() {
  return this.href;
};
$URL.prototype.toString = function toString() {
  return this.href;
};
Object.defineProperties($URL.prototype, prototypeAccessors);
function hasProtocol(inputStr, acceptProtocolRelative) {
  if (acceptProtocolRelative === void 0)
    acceptProtocolRelative = false;
  return /^\w+:\/\/.+/.test(inputStr) || acceptProtocolRelative && /^\/\/[^/]+/.test(inputStr);
}
var TRAILING_SLASH_RE = /\/$|\/\?/;
function hasTrailingSlash(input, queryParams) {
  if (input === void 0)
    input = "";
  if (queryParams === void 0)
    queryParams = false;
  if (!queryParams) {
    return input.endsWith("/");
  }
  return TRAILING_SLASH_RE.test(input);
}
function withTrailingSlash(input, queryParams) {
  if (input === void 0)
    input = "";
  if (queryParams === void 0)
    queryParams = false;
  if (!queryParams) {
    return input.endsWith("/") ? input : input + "/";
  }
  if (hasTrailingSlash(input, true)) {
    return input || "/";
  }
  var ref = input.split("?");
  var s0 = ref[0];
  var s2 = ref.slice(1);
  return s0 + "/" + (s2.length ? "?" + s2.join("?") : "");
}
function hasLeadingSlash(input) {
  if (input === void 0)
    input = "";
  return input.startsWith("/");
}
function withoutLeadingSlash(input) {
  if (input === void 0)
    input = "";
  return (hasLeadingSlash(input) ? input.substr(1) : input) || "/";
}
function getQuery(input) {
  return parseQuery(parseURL(input).search);
}
function parseURL(input, defaultProto) {
  if (input === void 0)
    input = "";
  if (!hasProtocol(input, true)) {
    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);
  }
  var ref = (input.replace(/\\/g, "/").match(/([^:/]+:)?\/\/([^/@]+@)?(.*)/) || []).splice(1);
  var protocol = ref[0];
  if (protocol === void 0)
    protocol = "";
  var auth = ref[1];
  var hostAndPath = ref[2];
  var ref$1 = (hostAndPath.match(/([^/?#]*)(.*)?/) || []).splice(1);
  var host = ref$1[0];
  if (host === void 0)
    host = "";
  var path = ref$1[1];
  if (path === void 0)
    path = "";
  var ref$2 = parsePath(path);
  var pathname = ref$2.pathname;
  var search = ref$2.search;
  var hash = ref$2.hash;
  return {
    protocol,
    auth: auth ? auth.substr(0, auth.length - 1) : "",
    host,
    pathname,
    search,
    hash
  };
}
function parsePath(input) {
  if (input === void 0)
    input = "";
  var ref = (input.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
  var pathname = ref[0];
  if (pathname === void 0)
    pathname = "";
  var search = ref[1];
  if (search === void 0)
    search = "";
  var hash = ref[2];
  if (hash === void 0)
    hash = "";
  return {
    pathname,
    search,
    hash
  };
}
function parseAuth(input) {
  if (input === void 0)
    input = "";
  var ref = input.split(":");
  var username = ref[0];
  var password = ref[1];
  return {
    username: decode(username),
    password: decode(password)
  };
}
function parseHost(input) {
  if (input === void 0)
    input = "";
  var ref = (input.match(/([^/]*)(:0-9+)?/) || []).splice(1);
  var hostname = ref[0];
  var port = ref[1];
  return {
    hostname: decode(hostname),
    port
  };
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  var arguments$1 = arguments;
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments$1[i] != null ? arguments$1[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) {
      descriptor.writable = true;
    }
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) {
    _defineProperties(Constructor.prototype, protoProps);
  }
  if (staticProps) {
    _defineProperties(Constructor, staticProps);
  }
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    return _arrayLikeToArray(arr);
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) {
    return arr;
  }
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) {
    return Array.from(iter);
  }
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) {
    return;
  }
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) {
        break;
      }
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) {
        _i["return"]();
      }
    } finally {
      if (_d) {
        throw _e;
      }
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2) {
    return;
  }
  if (typeof o2 === "string") {
    return _arrayLikeToArray(o2, minLen);
  }
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) {
    n2 = o2.constructor.name;
  }
  if (n2 === "Map" || n2 === "Set") {
    return Array.from(o2);
  }
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) {
    return _arrayLikeToArray(o2, minLen);
  }
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) {
    len = arr.length;
  }
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var VERSION$1 = "3.6.0";
var DOMAIN_REGEX = /^(?:[a-z\d\-_]{1,62}\.){0,125}(?:[a-z\d](?:\-(?=\-*[a-z\d])|[a-z]|\d){0,62}\.)[a-z\d]{1,63}$/i;
var MIN_SRCSET_WIDTH = 100;
var MAX_SRCSET_WIDTH = 8192;
var DEFAULT_SRCSET_WIDTH_TOLERANCE = 0.08;
var DPR_QUALITIES = {
  1: 75,
  2: 50,
  3: 35,
  4: 23,
  5: 20
};
var DEFAULT_DPR = [1, 2, 3, 4, 5];
var DEFAULT_OPTIONS = {
  domain: null,
  useHTTPS: true,
  includeLibraryParam: true,
  urlPrefix: "https://",
  secureURLToken: null
};
function extractUrl(_ref) {
  var _ref$url = _ref.url, url = _ref$url === void 0 ? "" : _ref$url, _ref$useHttps = _ref.useHttps, useHttps = _ref$useHttps === void 0 ? false : _ref$useHttps;
  var defaultProto = useHttps ? "https://" : "http://";
  if (!hasProtocol(url, true)) {
    return extractUrl({
      url: defaultProto + url
    });
  }
  return parseURL(url);
}
function validateAndDestructureOptions(options) {
  var widthTolerance;
  if (options.widthTolerance !== void 0) {
    validateWidthTolerance(options.widthTolerance);
    widthTolerance = options.widthTolerance;
  } else {
    widthTolerance = DEFAULT_SRCSET_WIDTH_TOLERANCE;
  }
  var minWidth = options.minWidth === void 0 ? MIN_SRCSET_WIDTH : options.minWidth;
  var maxWidth = options.maxWidth === void 0 ? MAX_SRCSET_WIDTH : options.maxWidth;
  if (minWidth != MIN_SRCSET_WIDTH || maxWidth != MAX_SRCSET_WIDTH) {
    validateRange(minWidth, maxWidth);
  }
  return [widthTolerance, minWidth, maxWidth];
}
function validateRange(min, max) {
  if (!(Number.isInteger(min) && Number.isInteger(max)) || min <= 0 || max <= 0 || min > max) {
    throw new Error("The min and max srcset widths can only be passed positive Number values, and min must be less than max. Found min: ".concat(min, " and max: ").concat(max, "."));
  }
}
function validateWidthTolerance(widthTolerance) {
  if (typeof widthTolerance != "number" || widthTolerance < 0.01) {
    throw new Error("The srcset widthTolerance must be a number greater than or equal to 0.01");
  }
}
function validateWidths(customWidths) {
  if (!Array.isArray(customWidths) || !customWidths.length) {
    throw new Error("The widths argument can only be passed a valid non-empty array of integers");
  } else {
    var allPositiveIntegers = customWidths.every(function(width) {
      return Number.isInteger(width) && width > 0;
    });
    if (!allPositiveIntegers) {
      throw new Error("A custom widths argument can only contain positive integer values");
    }
  }
}
function validateVariableQuality(disableVariableQuality) {
  if (typeof disableVariableQuality != "boolean") {
    throw new Error("The disableVariableQuality argument can only be passed a Boolean value");
  }
}
function validateDevicePixelRatios(devicePixelRatios) {
  if (!Array.isArray(devicePixelRatios) || !devicePixelRatios.length) {
    throw new Error("The devicePixelRatios argument can only be passed a valid non-empty array of integers");
  } else {
    var allValidDPR = devicePixelRatios.every(function(dpr) {
      return typeof dpr === "number" && dpr >= 1 && dpr <= 5;
    });
    if (!allValidDPR) {
      throw new Error("The devicePixelRatios argument can only contain positive integer values between 1 and 5");
    }
  }
}
function validateVariableQualities(variableQualities) {
  if (_typeof(variableQualities) !== "object") {
    throw new Error("The variableQualities argument can only be an object");
  }
}
var ImgixClient = function() {
  function ImgixClient2() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, ImgixClient2);
    this.settings = _objectSpread2(_objectSpread2({}, DEFAULT_OPTIONS), opts);
    this.targetWidthsCache = {};
    if (typeof this.settings.domain != "string") {
      throw new Error("ImgixClient must be passed a valid string domain");
    }
    if (DOMAIN_REGEX.exec(this.settings.domain) == null) {
      throw new Error('Domain must be passed in as fully-qualified domain name and should not include a protocol or any path element, i.e. "example.imgix.net".');
    }
    if (this.settings.includeLibraryParam) {
      this.settings.libraryParam = "js-" + ImgixClient2.version();
    }
    this.settings.urlPrefix = this.settings.useHTTPS ? "https://" : "http://";
  }
  _createClass(ImgixClient2, [{
    key: "buildURL",
    value: function buildURL() {
      var rawPath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var path = this._sanitizePath(rawPath, {
        encode: !options.disablePathEncoding
      });
      var finalParams = this._buildParams(params);
      if (!!this.settings.secureURLToken) {
        finalParams = this._signParams(path, finalParams);
      }
      return this.settings.urlPrefix + this.settings.domain + path + finalParams;
    }
  }, {
    key: "_buildParams",
    value: function _buildParams() {
      var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var queryParams = [].concat(_toConsumableArray(this.settings.libraryParam ? ["ixlib=".concat(this.settings.libraryParam)] : []), _toConsumableArray(Object.entries(params).reduce(function(prev, _ref) {
        var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
        if (value == null) {
          return prev;
        }
        var encodedKey = encodeURIComponent(key);
        var encodedValue = key.substr(-2) === "64" ? gBase64.encodeURI(value) : encodeURIComponent(value);
        prev.push("".concat(encodedKey, "=").concat(encodedValue));
        return prev;
      }, [])));
      return "".concat(queryParams.length > 0 ? "?" : "").concat(queryParams.join("&"));
    }
  }, {
    key: "_signParams",
    value: function _signParams(path, queryParams) {
      var signatureBase = this.settings.secureURLToken + path + queryParams;
      var signature = md5(signatureBase);
      return queryParams.length > 0 ? queryParams + "&s=" + signature : "?s=" + signature;
    }
  }, {
    key: "_sanitizePath",
    value: function _sanitizePath(path) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _path = path.replace(/^\//, "");
      if (!(options.encode === false)) {
        if (/^https?:\/\//.test(_path)) {
          _path = encodeURIComponent(_path);
        } else {
          _path = encodeURI(_path).replace(/[#?:+]/g, encodeURIComponent);
        }
      }
      return "/" + _path;
    }
  }, {
    key: "buildSrcSet",
    value: function buildSrcSet2(path) {
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var w = params.w, h2 = params.h;
      if (w || h2) {
        return this._buildDPRSrcSet(path, params, options);
      } else {
        return this._buildSrcSetPairs(path, params, options);
      }
    }
  }, {
    key: "_buildSrcSetPairs",
    value: function _buildSrcSetPairs(path) {
      var _this = this;
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var _validateAndDestructu = validateAndDestructureOptions(options), _validateAndDestructu2 = _slicedToArray(_validateAndDestructu, 3), widthTolerance = _validateAndDestructu2[0], minWidth = _validateAndDestructu2[1], maxWidth = _validateAndDestructu2[2];
      var targetWidthValues;
      if (options.widths) {
        validateWidths(options.widths);
        targetWidthValues = _toConsumableArray(options.widths);
      } else {
        targetWidthValues = ImgixClient2.targetWidths(minWidth, maxWidth, widthTolerance, this.targetWidthsCache);
      }
      var srcset = targetWidthValues.map(function(w) {
        return "".concat(_this.buildURL(path, _objectSpread2(_objectSpread2({}, params), {}, {
          w
        }), {
          disablePathEncoding: options.disablePathEncoding
        }), " ").concat(w, "w");
      });
      return srcset.join(",\n");
    }
  }, {
    key: "_buildDPRSrcSet",
    value: function _buildDPRSrcSet(path) {
      var _this2 = this;
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (options.devicePixelRatios) {
        validateDevicePixelRatios(options.devicePixelRatios);
      }
      var targetRatios = options.devicePixelRatios || DEFAULT_DPR;
      var disableVariableQuality = options.disableVariableQuality || false;
      if (!disableVariableQuality) {
        validateVariableQuality(disableVariableQuality);
      }
      if (options.variableQualities) {
        validateVariableQualities(options.variableQualities);
      }
      var qualities = _objectSpread2(_objectSpread2({}, DPR_QUALITIES), options.variableQualities);
      var withQuality = function withQuality2(path2, params2, dpr) {
        return "".concat(_this2.buildURL(path2, _objectSpread2(_objectSpread2({}, params2), {}, {
          dpr,
          q: params2.q || qualities[dpr] || qualities[Math.floor(dpr)]
        }), {
          disablePathEncoding: options.disablePathEncoding
        }), " ").concat(dpr, "x");
      };
      var srcset = disableVariableQuality ? targetRatios.map(function(dpr) {
        return "".concat(_this2.buildURL(path, _objectSpread2(_objectSpread2({}, params), {}, {
          dpr
        }), {
          disablePathEncoding: options.disablePathEncoding
        }), " ").concat(dpr, "x");
      }) : targetRatios.map(function(dpr) {
        return withQuality(path, params, dpr);
      });
      return srcset.join(",\n");
    }
  }], [{
    key: "version",
    value: function version2() {
      return VERSION$1;
    }
  }, {
    key: "_buildURL",
    value: function _buildURL(url) {
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (url == null) {
        return "";
      }
      var _extractUrl = extractUrl({
        url,
        useHTTPS: options.useHTTPS
      }), host = _extractUrl.host, pathname = _extractUrl.pathname, search = _extractUrl.search;
      var combinedParams = _objectSpread2(_objectSpread2({}, getQuery(search)), params);
      if (!host.length || !pathname.length) {
        throw new Error("_buildURL: URL must match {host}/{pathname}?{query}");
      }
      var client = new ImgixClient2(_objectSpread2({
        domain: host
      }, options));
      return client.buildURL(pathname, combinedParams);
    }
  }, {
    key: "_buildSrcSet",
    value: function _buildSrcSet(url) {
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var srcsetModifiers = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var clientOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (url == null) {
        return "";
      }
      var _extractUrl2 = extractUrl({
        url,
        useHTTPS: clientOptions.useHTTPS
      }), host = _extractUrl2.host, pathname = _extractUrl2.pathname, search = _extractUrl2.search;
      var combinedParams = _objectSpread2(_objectSpread2({}, getQuery(search)), params);
      if (!host.length || !pathname.length) {
        throw new Error("_buildOneStepURL: URL must match {host}/{pathname}?{query}");
      }
      var client = new ImgixClient2(_objectSpread2({
        domain: host
      }, clientOptions));
      return client.buildSrcSet(pathname, combinedParams, srcsetModifiers);
    }
  }, {
    key: "targetWidths",
    value: function targetWidths() {
      var minWidth = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
      var maxWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8192;
      var widthTolerance = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.08;
      var cache = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var minW = Math.floor(minWidth);
      var maxW = Math.floor(maxWidth);
      validateRange(minWidth, maxWidth);
      validateWidthTolerance(widthTolerance);
      var cacheKey = widthTolerance + "/" + minW + "/" + maxW;
      if (cacheKey in cache) {
        return cache[cacheKey];
      }
      if (minW === maxW) {
        return [minW];
      }
      var resolutions = [];
      var currentWidth = minW;
      while (currentWidth < maxW) {
        resolutions.push(Math.round(currentWidth));
        currentWidth *= 1 + widthTolerance * 2;
      }
      if (resolutions[resolutions.length - 1] < maxW) {
        resolutions.push(maxW);
      }
      cache[cacheKey] = resolutions;
      return resolutions;
    }
  }]);
  return ImgixClient2;
}();
var IxImgProps = {
  src: {
    type: String,
    required: true
  },
  fixed: Boolean,
  imgixParams: Object,
  width: [String, Number],
  height: [String, Number],
  attributeConfig: Object,
  disableVariableQuality: Boolean,
  sizes: [String]
};
var defaultAttributeMap$1 = {
  src: "src",
  srcset: "srcset"
};
var IxImg = defineComponent({
  props: IxImgProps,
  setup: function setup(props, ref) {
    var attrs = ref.attrs;
    var vueImgixSingleton = ensureVueImgixClientSingleton();
    var imgixParamsFromImgAttributes = Object.assign({}, props.fixed && Object.assign({}, props.width != null ? { w: props.width } : {}, props.height != null ? { h: props.height } : {}));
    var ref$1 = vueImgixSingleton.buildUrlObject(props.src, Object.assign({}, imgixParamsFromImgAttributes, props.imgixParams), {
      disableVariableQuality: Boolean(props.disableVariableQuality)
    });
    var src = ref$1.src;
    var srcset = ref$1.srcset;
    var attributeConfig = Object.assign({}, defaultAttributeMap$1, props.attributeConfig);
    return function() {
      var obj;
      return h("img", (obj = {}, obj[attributeConfig.src] = src, obj[attributeConfig.srcset] = srcset, obj.width = props.width, obj.height = props.height, obj.sizes = props.sizes, obj["data-testid"] = attrs["data-testid"] || void 0, obj));
    };
  }
});
function objectWithoutProperties(obj, exclude) {
  var target = {};
  for (var k in obj)
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1)
      target[k] = obj[k];
  return target;
}
var VERSION = "3.0.2";
var clientOptionDefaults = {
  includeLibraryParam: true
};
var VueImgixClient = function VueImgixClient2(options) {
  var this$1$1 = this;
  this.buildIxParams = function(ixParams) {
    return Object.assign({}, this$1$1.options.defaultIxParams, ixParams);
  };
  this.buildUrlObject = function(url, ixParams, options2) {
    if (options2 === void 0)
      options2 = {};
    var widths = options2.widths;
    var widthTolerance = options2.widthTolerance;
    var minWidth = options2.minWidth;
    var maxWidth = options2.maxWidth;
    var rest = objectWithoutProperties(options2, ["widths", "widthTolerance", "minWidth", "maxWidth"]);
    var sharedOptions = rest;
    var src = this$1$1._buildUrl(url, ixParams);
    var srcset = this$1$1._buildSrcSet(url, ixParams, Object.assign({}, {
      widths,
      widthTolerance,
      minWidth,
      maxWidth
    }, sharedOptions));
    return { src, srcset };
  };
  this.buildUrl = function(url, ixParams) {
    return this$1$1.client.buildURL(url, this$1$1.buildIxParams(ixParams));
  };
  this._buildUrl = function(url, ixParams) {
    if (!url.includes("://")) {
      return this$1$1.client.buildURL(url, this$1$1.buildIxParams(ixParams));
    } else {
      return ImgixClient._buildURL(url, this$1$1.buildIxParams(ixParams));
    }
  };
  this.buildSrcSet = function(url, ixParams, options2) {
    return this$1$1.client.buildSrcSet(url, this$1$1.buildIxParams(ixParams), options2);
  };
  this._buildSrcSet = function(url, ixParams, options2) {
    if (!url.includes("://")) {
      return this$1$1.client.buildSrcSet(url, this$1$1.buildIxParams(ixParams), options2);
    } else {
      return ImgixClient._buildSrcSet(url, this$1$1.buildIxParams(ixParams), options2);
    }
  };
  this.options = Object.assign({}, clientOptionDefaults, options);
  this.client = new ImgixClient({
    domain: this.options.domain,
    includeLibraryParam: false
  });
  if (this.options.includeLibraryParam) {
    this.client.settings.libraryParam = "vue-" + VERSION;
  }
};
var buildImgixClient = function(options) {
  var client = new VueImgixClient(Object.assign({}, options));
  return client;
};
var vueImgixClientSingleton = void 0;
var initVueImgix = function(options) {
  vueImgixClientSingleton = new VueImgixClient(options);
};
var ensureVueImgixClientSingleton = function() {
  if (vueImgixClientSingleton == null) {
    throw new Error("[@imgix/vue] Vue.use(VueImgix, {}) must be called before using exported methods. This is usually done in App.vue :)");
  }
  return vueImgixClientSingleton;
};
var buildUrlObject = function() {
  var args = [], len = arguments.length;
  while (len--)
    args[len] = arguments[len];
  var client = ensureVueImgixClientSingleton();
  return client.buildUrlObject.apply(client, args);
};
var buildUrl = function() {
  var args = [], len = arguments.length;
  while (len--)
    args[len] = arguments[len];
  var client = ensureVueImgixClientSingleton();
  return client._buildUrl.apply(client, args);
};
var buildSrcSet = function() {
  var args = [], len = arguments.length;
  while (len--)
    args[len] = arguments[len];
  var client = ensureVueImgixClientSingleton();
  return client._buildSrcSet.apply(client, args);
};
var IxPictureProps = defineComponent({
  props: {}
});
var IxPicture = defineComponent({
  mixins: [IxPictureProps],
  setup: function setup2(_, ref) {
    var slots = ref.slots;
    ensureVueImgixClientSingleton();
    var defaultSlots = slots && slots.default && slots.default();
    return function() {
      return h("picture", defaultSlots);
    };
  }
});
var defaultAttributeMap = {
  src: "src",
  srcset: "srcset"
};
var IxSource = defineComponent({
  props: {
    src: {
      type: String,
      required: true
    },
    imgixParams: Object,
    attributeConfig: Object
  },
  setup: function setup3(props) {
    var vueImgixSingleton = ensureVueImgixClientSingleton();
    var imgixParamsFromAttributes = {};
    var ref = vueImgixSingleton.buildUrlObject(props.src, Object.assign({}, imgixParamsFromAttributes, props.imgixParams));
    var srcset = ref.srcset;
    var attributeConfig = Object.assign({}, defaultAttributeMap, props.attributeConfig);
    var childAttrs = {};
    childAttrs[attributeConfig.srcset] = srcset;
    return function() {
      return h("source", childAttrs);
    };
  }
});
function install(_app, options) {
  if (install.installed) {
    return;
  }
  install.installed = true;
  initVueImgix(options);
  _app.component("ix-img", IxImg);
  _app.component("ix-picture", IxPicture);
  _app.component("ix-source", IxSource);
}
install.installed = false;
var plugin = {
  install
};

// dep:@imgix_vue
var imgix_vue_default = plugin;
export {
  IxImg,
  buildImgixClient,
  buildSrcSet,
  buildUrl,
  buildUrlObject,
  imgix_vue_default as default,
  ensureVueImgixClientSingleton,
  initVueImgix,
  install
};
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
//# sourceMappingURL=@imgix_vue.js.map
